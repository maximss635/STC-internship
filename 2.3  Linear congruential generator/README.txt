Ситуация следующая:
	x2 = (k * x1 + a) (mod m)	(1)
	x3 = (k * x2 + a) (mod m)	(2)
	x4 = (k * x3 + a) (mod m)	(3)
Известные параметры: x1, x2, x3, x4
Неизвестные параметры: k, a, m
Необходимо подобрать параметры k, a, m 
(так сказать взломать линейный конгруэнтный генератор)
и по этим параметрам посчитать x5 = k*x4+a (mod m)

Решение:
Предположим, что нам известно m
(по коду метод solveForSpecificM(T m), line 64)

Тогда, вычитая из (2) (1) получаем:
	x3-x2 = k * (x2-x1) (mod m)
Введем обозначения, l=x3-x2, r=x2-x1 (line 67,68)
	l = k * r (mod m)	// k - неизвестное, остальное все знаем
Это сравнение первой степени и по какой-то там теореме оно 
не имеет решений если l не делится на НОД(r,m) (line 71)
В противном случае не сложно найти решение этого сравнения (line 75-77)
Параметр a находим, например подставляя найденный параметр k в выражение (2) (line 80)
Осталось только проверить, что найденные параметры 
удовлетворят и для x4, то есть условию (3), line 85
Проверки line 86-87 в теории избыточны, но с ними спокойнее
Соответсвенно мы либо нашли, либо не нашли решение в виде пары параметров a, k для конкретного m

Про параметр m:
По условию задачи его верхняя граница 65536, то есть его можно просто перебирать, 
пытаясь найти для каждого очередного параметра m решение, в случае нахождения завершать поиск.

В первую очередь будем перебирать все m вида 2^i (line 15-24),
 так как это достаточно распространенный случай для линейного конгруэнтного генератора
И только если не найдем для таких m решений будем уже смотреть все m "в лоб" (line 26-35)



Недостатки данного кода:
В момент написания данного Readme обнаружена следующая ситуация:
В функции T solveForSpecificM(T m) - при поиске решений в виде параметов k, a для конкретного m
следующая ситуация - находим одно решение, проверяем подходит ли оно и условию (3) и делаем вывод отсюда:
либо мы нашли решение и оно подходит также и для (3) то есть мы нашли решение, либо мы нашли решение для (1) и (2),
но оно не подходит для (3) значит решений нет. Но это неправильный вывод. Можно поискать другие решения сравнения
	l = k * r (mod m) в виде параметра k и попробовать его для выражения (3). 
ведь в общем виде это сравнение имеет d=НОД(l,m) решений в классе вычета по модулю m. 
Проще, говоря, ВОЗМОЖНО, данная программа иногда не находит решение, которое на самом деле существует.
Во время тестирования решения почти всегда находились. Иногда, не находились при числах x1 x2 x3 x4 более 5 разрядов,
может, если улучшить код в данном месте, то ситуация станет лучше, однако времени нет и задания пора сдавать на проверку.
