Идея для многопоточного приложения следующая:
реализовать многопоточный тест Ферма проверки числа на простоту
Тест Ферма работает следующим образом -
допустим мы проверяем число n на простоту. Генерируется случайным образом
число a - вычисляем a^(n-1) (mod n), если получилось НЕ 1,
то число ТОЧНО СОСТАВНОЕ. Если получилось 1, то никакого вывода
о простоте числа сделать нельзя, но его вероятность быть простым увеличилась.
В таком случае число a генерируется заного и проверка делалается заного.
После некоторого числа неудачных иттераций можно сделать вывод, что число
ВЕРОЯТНО ПРОСТОЕ. То есть 100-процентные гарантии тест может дать только о том,
 что число составное.
Идея в том, чтобы сделать всё вышесказанное полезной работой потока.
То есть каждый поток имеет цикл, в котором на каждой иттерации генерирует
случайное число a (threadrunner.cpp line 53) выполняет возведение в степень
по модулю (threadrunner.cpp line 73-93) и либо заканчивает работу
(threadrunner.cpp line 60-64) либо переходит на следующую иттерацию.
Максимальное количество иттераций задает пользователь в окошке
(там может стоять некое дефолтное значение)

Каждый поток имеет 2 сигнала endItteration и endWork
(threadrunner.h line 37 38)

Которые связаны с соответсвующими слотами класса MainWindow в виде
колбек функций callBackThreadIter, callBackThreadOut
(mainwindow.h line 28-33)

Связываются они в mainwindow.cpp line 81-95

Визуализация происходит в виде 10 виджетов типа QProgressBar которые
отражают число выполненных иттераций каждым потоком (скриншот имеется)

Тут только появляется проблема - интуитивно хочется обновлять значение
progressBar'a в колбек функции callBackThreadIter, но этого делать нельзя,
потому что данная колбек-функция вызывается созданными потоками и, возможно,
одновременно. Рисование должно выполняться только главным потоком в Qt, поэтому
алгоритм будет следующий - заведем массив (mainwindow.h line 50) в котором
будем отражать количество выполненных итераций каждым потоком и колбек функция
будет его обновлять (синхронизация даже не нужна,тк каждый поток обращается к
своему элементу). А вот главный поток будет ждать выполнения всех потоков и, пока
ждет будет отображать на progressbar значения из массива
(mainwindow.cpp line 100 - 109). В этом цикле можно поставить задержку, чтобы
рисование происходило с неким таймаутом.

Еще один момент - чтобы главный поток во время обновления progressbar'ов мог
понять, что ВСЕ потоки закончили свою работу была заведена переменная
readyThreads (число готовых потоков mainwindow.h line 53).
Эта переменная будет инкриментиться в колбек функции callBackThreadOut
НО уже она является разделемым ресурсом, перед обращением к ней необходимо
лочиться на мьютекс (mainwindow.cpp line 142-150)


Недостатки:
Проверяет на простоту числа unsigned long long int. Не интересно. Хочется более длинные числа - 
добавить сюда длинную арифметику. Никакого класса по типу QBigInteger не было найдено, 
видимо нужны сторонние библиотеки.
